import { 
  AppConfig
} from "../../shared/types";
import path from "path";
import fs from "fs/promises";
import os from "os";
import { SoundManager } from "./SoundManager";

/**
 * 简化版 Hook 管理器
 * 基于统一配置结构
 */
export class HookManager {
  private claudeConfigPath: string;
  private hooksPath: string;
  private soundManager: SoundManager;

  constructor() {
    // Claude Code的配置路径
    this.claudeConfigPath = path.join(os.homedir(), '.claude', 'settings.json');
    this.hooksPath = path.join(os.homedir(), '.claude', 'hooks');
    this.soundManager = new SoundManager();
  }

  /**
   * 生成完整的 Hook 脚本
   * 基于统一配置结构
   */
  async generateHookScripts(config: AppConfig): Promise<boolean> {
    try {
      // 确保hooks目录存在
      await fs.mkdir(this.hooksPath, { recursive: true });

      // 生成hook脚本
      await this.generateSimpleHookScripts(config);
      await this.generatePostToolUseHook(config);

      // 更新Claude Code设置
      await this.updateClaudeSettings(config);

      return true;
    } catch (error) {
      console.error('生成Hook脚本失败:', error);
      return false;
    }
  }

  /**
   * 生成简单Hook事件脚本
   */
  private async generateSimpleHookScripts(config: AppConfig): Promise<void> {
    const simpleHooks = ['userPromptSubmit', 'sessionStart', 'stop', 'notification'] as const;
    
    for (const hookName of simpleHooks) {
      const soundId = config.simpleHooks[hookName];
      if (soundId && soundId.trim() !== '') {
        console.log(`[HookManager] 生成 ${hookName} Hook 脚本`);
        const soundFilename = await this.getSoundFilename(soundId);
        const scriptContent = this.generateSimpleHookScript(hookName, soundFilename);
        const scriptPath = path.join(this.hooksPath, `${hookName}_hook.py`);
        await fs.writeFile(scriptPath, scriptContent, 'utf8');
      } else {
        console.log(`[HookManager] ${hookName} Hook 未配置音效，跳过脚本生成`);
        // 删除可能存在的旧脚本文件
        const scriptPath = path.join(this.hooksPath, `${hookName}_hook.py`);
        try {
          await fs.unlink(scriptPath);
          console.log(`[HookManager] 已删除 ${hookName} Hook 脚本`);
        } catch (error) {
          // 文件不存在时忽略错误
        }
      }
    }
  }

  /**
   * 生成 PostToolUse Hook
   */
  private async generatePostToolUseHook(config: AppConfig): Promise<void> {
    // 检查是否有任何工具配置了音效（非null值）
    const hasValidToolConfigs = Object.values(config.postToolUse).some(toolConfig => 
      (toolConfig.success && toolConfig.success.trim() !== '') || 
      (toolConfig.error && toolConfig.error.trim() !== '')
    );
    
    if (!hasValidToolConfigs) {
      console.log(`[HookManager] PostToolUse Hook 未配置任何音效，跳过脚本生成`);
      // 删除可能存在的旧脚本文件
      const scriptPath = path.join(this.hooksPath, 'postToolUse_hook.py');
      try {
        await fs.unlink(scriptPath);
        console.log(`[HookManager] 已删除 PostToolUse Hook 脚本`);
      } catch (error) {
        // 文件不存在时忽略错误
      }
      return;
    }

    console.log(`[HookManager] 生成PostToolUse脚本（工具级配置）`);
    const scriptContent = this.generatePostToolUseScript(config);
    
    const scriptPath = path.join(this.hooksPath, 'postToolUse_hook.py');
    await fs.writeFile(scriptPath, scriptContent, 'utf8');
  }

  /**
   * 获取音效文件名
   */
  private async getSoundFilename(soundId: string): Promise<string> {
    try {
      const sounds = await this.soundManager.getAvailableSounds();
      const sound = sounds.find(s => s.id === soundId);
      return sound ? sound.filename : 'default.wav';
    } catch (error) {
      console.error('获取音效文件名失败:', error);
      return 'default.wav';
    }
  }

  /**
   * 生成简单Hook脚本
   */
  private generateSimpleHookScript(hookType: string, soundFilename: string): string {
    return `#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
${hookType} Hook Script
Generated by Claude Code Cue
"""

import sys
import json
import subprocess
import platform
import os
from pathlib import Path

def play_sound(sound_file):
    """播放音效文件"""
    try:
        # 尝试多个可能的音效文件路径
        possible_paths = [
            # 1. 应用资源目录（生产环境）
            Path('/Applications/Claude Code Cue.app/Contents/Resources/sounds') / sound_file,
            # 2. 用户数据目录
            Path.home() / '.claude-code-cue' / 'sounds' / sound_file,
            # 3. 当前目录的sounds子目录
            Path.cwd() / 'sounds' / sound_file
        ]
        
        sound_path = None
        for path in possible_paths:
            if path.exists():
                sound_path = path
                break
        
        if not sound_path:
            print(f"音效文件不存在，已尝试路径: {[str(p) for p in possible_paths]}")
            return
        
        # 根据操作系统选择播放方式
        system = platform.system()
        if system == "Darwin":  # macOS
            subprocess.run(["afplay", str(sound_path)], check=True)
        elif system == "Linux":
            # 尝试多种Linux音频播放器
            players = ["paplay", "aplay", "play"]
            for player in players:
                try:
                    subprocess.run([player, str(sound_path)], check=True)
                    break
                except (subprocess.CalledProcessError, FileNotFoundError):
                    continue
        elif system == "Windows":
            # Windows使用PowerShell播放
            cmd = f'(New-Object Media.SoundPlayer "{sound_path}").PlaySync()'
            subprocess.run(["powershell", "-Command", cmd], check=True)
    except Exception as e:
        print(f"播放音效失败: {e}")

def main():
    """主函数"""
    try:
        # 播放音效
        play_sound("${soundFilename}")
    except Exception as e:
        print(f"Hook执行失败: {e}")
    
    sys.exit(0)

if __name__ == "__main__":
    main()
`;
  }

  /**
   * 生成PostToolUse脚本
   */
  private generatePostToolUseScript(config: AppConfig): string {
    // 将null值转换为Python的None
    const toolMappings = JSON.stringify(config.postToolUse, null, 2)
      .replace(/: null/g, ': None');
    
    return `#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PostToolUse Hook Script
Generated by Claude Code Cue
"""

import sys
import json
import subprocess
import platform
import os
from pathlib import Path

# 工具音效映射
TOOL_SOUND_MAPPINGS = ${toolMappings}

def play_sound(sound_file):
    """播放音效文件"""
    try:
        # 尝试多个可能的音效文件路径
        possible_paths = [
            # 1. 应用资源目录（生产环境）
            Path('/Applications/Claude Code Cue.app/Contents/Resources/sounds') / sound_file,
            # 2. 用户数据目录
            Path.home() / '.claude-code-cue' / 'sounds' / sound_file,
            # 3. 当前目录的sounds子目录
            Path.cwd() / 'sounds' / sound_file
        ]
        
        sound_path = None
        for path in possible_paths:
            if path.exists():
                sound_path = path
                break
        
        if not sound_path:
            print(f"音效文件不存在，已尝试路径: {[str(p) for p in possible_paths]}")
            return
        
        # 根据操作系统选择播放方式
        system = platform.system()
        if system == "Darwin":  # macOS
            subprocess.run(["afplay", str(sound_path)], check=True)
        elif system == "Linux":
            # 尝试多种Linux音频播放器
            players = ["paplay", "aplay", "play"]
            for player in players:
                try:
                    subprocess.run([player, str(sound_path)], check=True)
                    break
                except (subprocess.CalledProcessError, FileNotFoundError):
                    continue
        elif system == "Windows":
            # Windows使用PowerShell播放
            cmd = f'(New-Object Media.SoundPlayer "{sound_path}").PlaySync()'
            subprocess.run(["powershell", "-Command", cmd], check=True)
    except Exception as e:
        print(f"播放音效失败: {e}")

def determine_tool_success(tool_name, response):
    """判断工具执行是否成功"""
    if not response:
        return False
    
    # 简单的成功判断逻辑
    if isinstance(response, dict):
        if 'error' in response or 'Error' in str(response):
            return False
        return True
    
    if isinstance(response, str):
        error_keywords = ['error', 'Error', 'failed', 'Failed', 'exception', 'Exception']
        return not any(keyword in response for keyword in error_keywords)
    
    return True

def get_tool_sound(tool_name, response):
    """获取工具对应的音效"""
    if tool_name not in TOOL_SOUND_MAPPINGS:
        # 使用默认音效
        is_success = determine_tool_success(tool_name, response)
        return 'success.wav' if is_success else 'error.wav'
    
    tool_config = TOOL_SOUND_MAPPINGS[tool_name]
    is_success = determine_tool_success(tool_name, response)
    
    # 根据执行结果选择音效
    if is_success:
        sound_file = tool_config.get('success')
    else:
        sound_file = tool_config.get('error')
    
    # 如果配置为null或None，表示无配置，不播放音效
    if sound_file is None or sound_file == 'null':
        return None
    
    # 如果是空字符串，使用默认音效
    if not sound_file or sound_file.strip() == '':
        return 'success.wav' if is_success else 'error.wav'
    
    # 确保音效文件有扩展名
    if not sound_file.endswith(('.wav', '.mp3', '.aac', '.ogg', '.m4a')):
        sound_file += '.wav'
    
    return sound_file

def main():
    """主函数"""
    try:
        # 读取输入数据
        input_data = json.load(sys.stdin)
        tool_name = input_data.get('tool_name', '')
        tool_response = input_data.get('tool_response', {})
        
        # 获取对应的音效
        sound_file = get_tool_sound(tool_name, tool_response)
        
        if sound_file:
            play_sound(sound_file)
        elif sound_file is None:
            print(f"工具 {tool_name} 未配置音效，跳过播放")
        else:
            print(f"未找到工具 {tool_name} 的音效配置")
            
    except Exception as e:
        print(f"Hook执行失败: {e}")
    
    sys.exit(0)

if __name__ == "__main__":
    main()
`;
  }

  /**
   * 更新Claude Code设置
   */
  private async updateClaudeSettings(config: AppConfig): Promise<void> {
    try {
      let settings: any = {};
      
      // 尝试读取现有设置并创建备份
      try {
        const settingsContent = await fs.readFile(this.claudeConfigPath, 'utf8');
        settings = JSON.parse(settingsContent);
        
        // 创建备份文件
        await this.createSettingsBackup(settingsContent);
      } catch (error) {
        console.log('创建新的settings.json文件');
      }
      
      // 确保hooks对象存在
      if (!settings.hooks) {
        settings.hooks = {};
      }
      
      // 清除现有的Hook配置
      const hookTypes = ['UserPromptSubmit', 'SessionStart', 'Stop', 'Notification', 'PostToolUse'];
      hookTypes.forEach(hookType => {
        delete settings.hooks[hookType];
      });
      
      // 添加简单Hook事件配置
      Object.entries(config.simpleHooks).forEach(([hookName, soundId]) => {
        if (soundId && soundId.trim() !== '') {
          const officialHookName = this.getOfficialHookName(hookName);
          settings.hooks[officialHookName] = [{
            hooks: [{
              type: "command",
              command: `python3 "${path.join(this.hooksPath, `${hookName}_hook.py`)}"`,
              timeout: 5
            }]
          }];
        }
      });
      
      // 添加PostToolUse配置
      const hasPostToolUseConfig = Object.keys(config.postToolUse).length > 0;
      
      if (hasPostToolUseConfig) {
        settings.hooks['PostToolUse'] = [{
          matcher: "*",
          hooks: [{
            type: "command",
            command: `python3 "${path.join(this.hooksPath, 'postToolUse_hook.py')}"`,
            timeout: 5
          }]
        }];
      }
      
      // 添加schema
      settings['$schema'] = 'https://json.schemastore.org/claude-code-settings.json';
      
      // 写入设置文件
      await fs.writeFile(this.claudeConfigPath, JSON.stringify(settings, null, 2), 'utf8');
      console.log('Claude Code设置已更新');
      
    } catch (error) {
      console.error('更新Claude Code设置失败:', error);
      throw error;
    }
  }
  
  /**
   * 创建settings.json备份文件
   */
  private async createSettingsBackup(settingsContent: string): Promise<void> {
    try {
      // 生成备份文件名：settings.backup.YYYYMMDD.json
      const now = new Date();
      const dateStr = now.getFullYear().toString() + 
                     (now.getMonth() + 1).toString().padStart(2, '0') + 
                     now.getDate().toString().padStart(2, '0');
      
      const backupFileName = `settings.backup.${dateStr}.json`;
      const backupPath = path.join(path.dirname(this.claudeConfigPath), backupFileName);
      
      // 检查备份文件是否已存在（避免同一天重复备份）
      try {
        await fs.access(backupPath);
        console.log(`备份文件已存在: ${backupFileName}`);
        return;
      } catch (error) {
        // 文件不存在，继续创建备份
      }
      
      // 写入备份文件
      await fs.writeFile(backupPath, settingsContent, 'utf8');
      console.log(`已创建settings.json备份: ${backupFileName}`);
      
    } catch (error) {
      console.error('创建备份文件失败:', error);
      // 备份失败不应该阻止配置更新，只记录错误
    }
  }

  /**
   * 获取官方Hook名称
   */
  private getOfficialHookName(hookType: string): string {
    const mapping: Record<string, string> = {
      'userPromptSubmit': 'UserPromptSubmit',
      'sessionStart': 'SessionStart',
      'stop': 'Stop',
      'notification': 'Notification',
      'postToolUse': 'PostToolUse'
    };
    return mapping[hookType] || hookType;
  }

  /**
   * 检查Claude Code安装
   */
  async checkClaudeCodeInstallation(): Promise<boolean> {
    try {
      const claudeDir = path.dirname(this.claudeConfigPath);
      await fs.access(claudeDir);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 移除所有Hook
   */
  async removeAllHooks(): Promise<boolean> {
    try {
      // 清理Hook脚本文件
      const hookFiles = [
        'userPromptSubmit_hook.py',
        'sessionStart_hook.py', 
        'stop_hook.py',
        'notification_hook.py',
        'postToolUse_hook.py'
      ];
      
      for (const file of hookFiles) {
        const filePath = path.join(this.hooksPath, file);
        try {
          await fs.unlink(filePath);
        } catch {
          // 文件不存在，忽略错误
        }
      }
      
      // 清理settings.json中的Hook配置
      try {
        const settingsContent = await fs.readFile(this.claudeConfigPath, 'utf8');
        const settings = JSON.parse(settingsContent);
        
        if (settings.hooks) {
          const hookTypes = ['UserPromptSubmit', 'SessionStart', 'Stop', 'Notification', 'PostToolUse'];
          hookTypes.forEach(hookType => {
            delete settings.hooks[hookType];
          });
          
          await fs.writeFile(this.claudeConfigPath, JSON.stringify(settings, null, 2), 'utf8');
        }
      } catch (error) {
        console.error('清理settings.json失败:', error);
      }
      
      return true;
    } catch (error) {
      console.error('移除Hook失败:', error);
      return false;
    }
  }
}